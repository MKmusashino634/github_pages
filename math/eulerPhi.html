<!-- Generated by Bing AI -->
<!-- prompt:
「テキストボックスから入力して、
オイラー函数の結果を出力するHTMLコードを書いて」
其の後、
「もっと効率化して」
其の後、手直しした。

が、上手くいかないので、
ChatGPTに同様にお願いした。
-->
<!DOCTYPE html>
<html lang="ja">
<head>
	<!--
		head参照
		「http://www.yamamo10.jp/yamamoto/internet/WEB/MathJax/index.php」
	-->
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});
	</script>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML,/www_func/MathJax/MyConfig.js">
	</script>
	</head>
<body>

<h2>オイラー函数; Euler's totient function</h2>

<p>
	入力した自然数nと互いに素なn以下の自然数の個数を調べる。<br>
	\begin{align}
		\varphi( n ) = \sum_{1 \leq m \leq n, \; gcd(m, n) = 1} 1
	\end{align}
</p>
<input id="num" type="text">
<button onclick="calculateEuler()">計算</button>
<p id="result"></p>
<p>
	<br>
	<br>
	定理<br>
</p>
<ol>
	<li>
		乗法的函数：
					\begin{align}
						\varphi( mn ) = \varphi( m ) \varphi( n )
					\end{align}
	</li>
	<li>
		\begin{align}
			n = p_1^{a_1} p_2^{a_2} p_3^{a_3} \dots p_k^{a_k}のとき、
			\varphi( n ) = n\prod_{j = 1}^k (1 - \frac{1}{p_j})
		\end{align}
	</li>
	<li>
		\begin{align}
			\sum_{d|n} \varphi( d ) = n (\sum_{d|n}はnの正の約数dの和)
		\end{align}
	</li>
</ol>

<p>
	<br>
	<br>
	<br>
</p>

<script>
	function eulerPhi(n) {
		if (n == 1) return 1;

		let result = n;
		for (let i = 2; i * i <= n; i++) {
			if (n % i === 0) {
				while (n % i === 0) {
					n /= i;
				}
				result -= result / i;
			}
		}

		if (n > 1) {
			result -= result / n;
		}

		return result;
	}

	function calculateEuler() {
		var num = document.getElementById("num").value;
		num = parseInt(num);

		if (isNaN(num) || num <= 0) {
			document.getElementById("result").innerHTML = "有効な自然数を入力してください。";
		} else {
			var result = eulerPhi(num);
			document.getElementById("result").innerHTML = "φ(" + num + ") = " + result;
		}
	}
	</script>


<!--
Bing AIより。
<script>
	var MAX_SIZE = 1000001;
	var isprime = new Array(MAX_SIZE).fill(true);
	var prime = new Array(MAX_SIZE);
	var SPF = new Array(MAX_SIZE);	//SPF[n]は数値nの最小の素因数;Smallest Prime Factor

	function manipulated_seive(N) {
		isprime[0] = isprime[1] = false;
		for (let i=2; i<=N; i++) {
			if (isprime[i]) {
				prime.push(i);
				SPF[i] = i;
			}
			// i * prime[j]がN以下で、prime[j]がSPF[i]以下の場合に最小素因数を記録
			for (let j = 0; j < prime.length && i * prime[j] <= N && prime[j] <= SPF[i]; j++) {
				isprime[i * prime[j]] = false;
				SPF[i * prime[j]] = prime[j];
			}
		}
	}

	function eulerPhi(n) {
		if (n==1) return 1;
		return SPF[n];
	}

	// event handler
	function calculateEuler() {
		var num = document.getElementById("num").value;
		var result = eulerPhi(num);
		document.getElementById("result").innerHTML = "φ(" + num + ") = " + result;
	}

	manipulated_seive(MAX_SIZE);
</script>
-->

</body>
</html>

